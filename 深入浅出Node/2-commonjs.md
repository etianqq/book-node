## 模块机制-common.js

### 模块实现

#### 模块分类

* 核心模块（Node提供）
  * 在Node源代码编译过程中，编译进了二进制执行文件。在Node进程启动时，核心模块被直接加载如内存。
  * 在路径分析中优化判断
  * 加载速度最快
* 文件模块（用户编写）
  * 运行是动态加载。
  * 需要完整的路径分析->文件定位->编译执行过程
  * 加载速度比核心模块慢

#### 模块缓存加载

第二次加载时都采用缓存优先的方式。核心模块的缓存检查先于文件模块。



### 核心模块

由C或C++编写，或者C/C++完成核心部分，其他部分由JavaScript实现包装或向外导出。

用纯C或C++编写的模块成为**内建模块**。文件模块不可以直接调用内建模块。

> 文件模块
>
> ​       |
>
> 核心模块
>
> ​       |
>
> 内建模块

### 包与NPM

包是一个存档文件，即一个目录直接打包为.zip或者tar.gz格式的文件，安装后解压还原为目录。

符合common.js规范的包目录应该包含如下文件：

* package.json：包描述文件
* bin：可执行的二进制文件目录
* lib：存放JavaScript代码的目录
* doc：文档目录
* test：单元测试目录

### 同步加载

common.js的包是同步加载，因为它设计之初就是为服务端服务的。如果用在浏览器那段，很多场景需要异步加载模式，可以考虑使用AMD，CMD或ES6规范。

当然，common.js也提供了异步加载的函数：`require.ensure`

```javascript
require.ensure([], function(require){
    var list = require('./list');
    list.show();
});
```



### 与ES6区别

1. ES6模块的设计思想，是尽量的静态化，使得`编译时`就能确定模块的依赖关系(“静态优化”)，以及输入和输出的变量。CommonJS和AMD模块，都只能在`运行时`确定这些东西(“运行时加载”)。

2. ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。
   CommonJS和AMD模块是一个对象。

3. ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。

   CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

4. 处理“循环加载”的方法是不一样的，返回的结果也不一样。

CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。

ES6模块是动态引用，如果使用`import`从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。